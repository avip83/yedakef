<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§© ×¤××–×œ ×××™×ª×™ - ×™×“×¢×§×£</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Heebo', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .puzzle-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .puzzle-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            z-index: 1000;
        }

        .puzzle-title {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .puzzle-progress {
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 10px 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .puzzle-board {
            position: absolute;
            top: 50%;
            left: 35%;
            transform: translate(-50%, -50%);
            width: 360px;
            height: 360px;
            background: rgba(255,255,255,0.1);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.2);
        }

        .puzzle-pieces-area {
            position: absolute;
            top: 50%;
            right: 10%;
            transform: translateY(-50%);
            width: 350px;
            height: 500px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            padding: 20px;
        }

        .pieces-title {
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        .puzzle-piece {
            position: absolute;
            cursor: grab;
            transition: all 0.2s ease;
            z-index: 10;
            filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            shape-rendering: geometricPrecision;
        }

        .puzzle-piece:hover {
            transform: scale(1.05);
            z-index: 50;
            filter: drop-shadow(5px 5px 15px rgba(0,0,0,0.6));
        }

        .puzzle-piece.dragging {
            z-index: 100;
            transform: scale(1.1);
            filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.8));
            cursor: grabbing;
        }

        .puzzle-piece.connected {
            cursor: default;
            filter: none;
            z-index: 5;
        }

        .puzzle-piece.snapping {
            animation: snapPiece 0.4s ease-out;
        }

        @keyframes snapPiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); filter: drop-shadow(0 0 20px rgba(76,175,80,0.8)); }
            100% { transform: scale(1); }
        }

        .puzzle-slot {
            position: absolute;
            border: none;
            background: transparent;
            transition: all 0.3s ease;
        }

        .puzzle-slot.highlight {
            background: rgba(76,175,80,0.2);
            box-shadow: 0 0 20px rgba(76,175,80,0.6);
            border-radius: 10px;
        }

        .control-buttons {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .control-button {
            padding: 12px 24px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .control-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .back-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(244,67,54,0.8);
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(244,67,54,1);
        }

        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            z-index: 2000;
            display: none;
        }

        .completion-title {
            font-size: 2.5rem;
            color: #4caf50;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .completion-text {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div class="puzzle-container">
        <!-- Header -->
        <div class="puzzle-header">
            <div class="puzzle-title">ğŸ§© ×¤××–×œ ×××™×ª×™ - ×’×¨×¡×” ×—×“×©×”!</div>
            <div class="puzzle-progress">
                <div>×—×œ×§×™× ××—×•×‘×¨×™×: <span id="connected-count">0</span>/9</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div id="progress-percent">0% ×”×•×©×œ×</div>
            </div>
        </div>

        <!-- Board -->
        <div class="puzzle-board" id="puzzle-board"></div>

        <!-- Pieces Area -->
        <div class="puzzle-pieces-area">
            <div class="pieces-title">ğŸ§© ×—×ª×™×›×•×ª ×”×¤××–×œ</div>
            <div id="pieces-container"></div>
        </div>

        <!-- Controls -->
        <div class="control-buttons">
            <button class="control-button" onclick="shufflePieces()">ğŸ”„ ×¤×–×¨ ××—×“×©</button>
            <button class="control-button" onclick="showHint()">ğŸ’¡ ×¨××–</button>
        </div>

        <!-- Back Button -->
        <button class="control-button back-button" onclick="goBack()">â¬…ï¸ ×—×–×•×¨</button>

        <!-- Completion Message -->
        <div class="completion-message" id="completion-message">
            <div class="completion-title">ğŸ‰ ×›×œ ×”×›×‘×•×“! ğŸ‰</div>
            <div class="completion-text">×”×©×œ××ª ××ª ×”×¤××–×œ ×‘×”×¦×œ×—×”!</div>
            <button class="control-button" onclick="resetPuzzle()">ğŸ”„ ×¤××–×œ ×—×“×©</button>
            <button class="control-button" onclick="goBack()">ğŸ  ×—×–×•×¨ ×œ×ª×¤×¨×™×˜</button>
        </div>
    </div>

    <script>
        class RealPuzzle {
            constructor() {
                this.gridSize = 3;
                this.pieceSize = 120; // ×’×•×“×œ ×”×—×œ×§ ××ª××™× ×œ×’×•×“×œ ×”×¨×™×‘×•×¢
                this.boardSize = 360;
                this.pieces = [];
                this.connectedPieces = 0;
                this.currentImage = 'puzzle/6.png';
                this.sounds = {};
                // ×™×¦×™×¨×ª ××¤×ª ×—×™×‘×•×¨×™× ×œ×•×’×™×ª
                this.edgeMap = this.generateEdgeMap();
                this.loadSounds();
                this.init();
            }

            generateEdgeMap() {
                // ××¤×ª ×—×™×‘×•×¨×™× ×œ×¤×™ ×”××¤×¨×˜ ×”××“×•×™×§:
                // 0: ×¤×™× ×” ×©×××œ ×¢×œ×™×•×Ÿ - ×§×• ×¢×œ×™×•×Ÿ ×•×©×××œ×™, ×‘×œ×™×˜×” ×™××™× ×” ×•×œ××˜×”
                // 1: ×××¦×¢ ×¢×œ×™×•×Ÿ - ×§×• ×¢×œ×™×•×Ÿ, ×—×•×¨ ××©×××œ ×•××™××™×Ÿ, ×‘×œ×™×˜×” ×œ××˜×”
                // 2: ×¤×™× ×” ×™××™×Ÿ ×¢×œ×™×•×Ÿ - ×§×• ×¢×œ×™×•×Ÿ ×•×™×× ×™, ×—×•×¨ ×œ××˜×”, ×‘×œ×™×˜×” ×©×××œ×”
                // 3: ×××¦×¢ ×©×××œ - ×§×• ×©×××œ×™, ×—×•×¨ ×œ××¢×œ×”, ×‘×œ×™×˜×•×ª ×™××™× ×” ×•×œ××˜×”
                // 4: ××¨×›×– - ×—×•×¨×™× ××›×œ ×”×¦×“×“×™×
                // 5: ×××¦×¢ ×™××™×Ÿ - ×§×• ×™×× ×™, ×‘×œ×™×˜×•×ª ×‘×©××¨ ×”×¦×“×“×™×
                // 6: ×¤×™× ×” ×©×××œ ×ª×—×ª×•×Ÿ - ×§×• ×ª×—×ª×•×Ÿ ×•×©×××œ×™, ×—×•×¨×™× ×œ××¢×œ×” ×•×œ×™××™×Ÿ
                // 7: ×××¦×¢ ×ª×—×ª×•×Ÿ - ×§×• ×ª×—×ª×•×Ÿ, ×‘×œ×™×˜×•×ª ×‘×©××¨ ×”×¦×“×“×™×
                // 8: ×¤×™× ×” ×™××™×Ÿ ×ª×—×ª×•×Ÿ - ×§×• ×ª×—×ª×•×Ÿ ×•×™×× ×™, ×—×•×¨ ×œ××¢×œ×” ×•×©×××œ×”
                
                const edges = {};
                
                // ×§×¦×•×•×ª ××•×¤×§×™×™× (×™××™×Ÿ-×©×××œ) - ××ª×•×§×Ÿ ×œ×¤×™ ×”××¤×¨×˜ ×”××“×•×™×§
                // ×©×•×¨×” 0: [0,0]--[0,1]  [0,1]--[0,2]  
                edges['h_0_0'] = true;   // ×—×œ×§ 0: ×‘×œ×™×˜×” ×™××™× ×” â† â†’ ×—×œ×§ 1: ×—×•×¨ ××©×××œ
                edges['h_0_1'] = false;  // ×—×œ×§ 1: ×—×•×¨ ××™××™×Ÿ â† â†’ ×—×œ×§ 2: ×‘×œ×™×˜×” ×©×××œ×”
                
                // ×©×•×¨×” 1: [1,0]--[1,1]  [1,1]--[1,2]
                edges['h_1_0'] = true;   // ×—×œ×§ 3: ×‘×œ×™×˜×” ×™××™× ×” â† â†’ ×—×œ×§ 4: ×—×•×¨ ××©×××œ  
                edges['h_1_1'] = false;  // ×—×œ×§ 4: ×—×•×¨ ××™××™×Ÿ â† â†’ ×—×œ×§ 5: ×‘×œ×™×˜×” ×©×××œ×”
                
                // ×©×•×¨×” 2: [2,0]--[2,1]  [2,1]--[2,2]
                edges['h_2_0'] = false;  // ×—×œ×§ 6: ×—×•×¨ ×™××™× ×” â† â†’ ×—×œ×§ 7: ×‘×œ×™×˜×” ×©×××œ×”
                edges['h_2_1'] = true;   // ×—×œ×§ 7: ×‘×œ×™×˜×” ×™××™× ×” â† â†’ ×—×œ×§ 8: ×—×•×¨ ×©×××œ×”
                
                // ×§×¦×•×•×ª ×× ×›×™×™× (×œ××¢×œ×”-×œ××˜×”) - ××ª×•×§×Ÿ ×œ×¤×™ ×”××¤×¨×˜ ×”××“×•×™×§
                // ×¢××•×“×” 0: [0,0]--[1,0]  [1,0]--[2,0]
                edges['v_0_0'] = true;   // ×—×œ×§ 0: ×‘×œ×™×˜×” ×œ××˜×” â†• ×—×œ×§ 3: ×—×•×¨ ×œ××¢×œ×”
                edges['v_1_0'] = true;   // ×—×œ×§ 3: ×‘×œ×™×˜×” ×œ××˜×” â†• ×—×œ×§ 6: ×—×•×¨ ×œ××¢×œ×”
                
                // ×¢××•×“×” 1: [0,1]--[1,1]  [1,1]--[2,1]  
                edges['v_0_1'] = true;   // ×—×œ×§ 1: ×‘×œ×™×˜×” ×œ××˜×” â†• ×—×œ×§ 4: ×—×•×¨ ×œ××¢×œ×”
                edges['v_1_1'] = false;  // ×—×œ×§ 4: ×—×•×¨ ×œ××˜×” â†• ×—×œ×§ 7: ×‘×œ×™×˜×” ×œ××¢×œ×”
                
                // ×¢××•×“×” 2: [0,2]--[1,2]  [1,2]--[2,2]
                edges['v_0_2'] = false;  // ×—×œ×§ 2: ×—×•×¨ ×œ××˜×” â†• ×—×œ×§ 5: ×‘×œ×™×˜×” ×œ××¢×œ×”
                edges['v_1_2'] = true;   // ×—×œ×§ 5: ×‘×œ×™×˜×” ×œ××˜×” â†• ×—×œ×§ 8: ×—×•×¨ ×œ××¢×œ×”
                
                return edges;
            }

            loadSounds() {
                this.sounds = {
                    drag: new Audio('sounds/plop-sound-made-with-my-mouth-100690 (mp3cut.net).mp3'),
                    snap: new Audio('sounds/mouse-click-290204.mp3'),
                    complete: new Audio('sounds/game-level-complete-143022.mp3')
                };
                Object.values(this.sounds).forEach(sound => sound.volume = 0.6);
            }

            playSound(type) {
                if (this.sounds[type] && !window.__globalMute) {
                    try {
                        this.sounds[type].currentTime = 0;
                        this.sounds[type].play();
                    } catch (e) {}
                }
            }

            init() {
                this.createPuzzleSlots();
                this.createPuzzlePieces();
            }

            createPuzzleSlots() {
                const board = document.getElementById('puzzle-board');
                const slotSize = this.boardSize / this.gridSize;

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const slot = document.createElement('div');
                        slot.className = 'puzzle-slot';
                        // ×—×œ×§×™× ×¦××•×“×™× ×œ×’××¨×™ - ××™×Ÿ ×¨×•×•×—×™×
                        slot.style.left = (col * slotSize) + 'px';
                        slot.style.top = (row * slotSize) + 'px';
                        slot.style.width = slotSize + 'px';
                        slot.style.height = slotSize + 'px';
                        slot.dataset.row = row;
                        slot.dataset.col = col;
                        board.appendChild(slot);
                    }
                }
            }

            createPuzzlePieces() {
                const container = document.getElementById('pieces-container');
                const pieceSize = this.boardSize / this.gridSize;

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const piece = this.createPuzzlePiece(row, col, pieceSize);
                        piece.correctRow = row;
                        piece.correctCol = col;
                        piece.connected = false;

                        // ××™×§×•× ××§×¨××™ ×‘××–×•×¨ ×”×—×ª×™×›×•×ª
                        const randomX = Math.random() * 250;
                        const randomY = Math.random() * 400;
                        piece.style.left = randomX + 'px';
                        piece.style.top = randomY + 'px';

                        document.body.appendChild(piece);
                        this.pieces.push(piece);
                        this.addPieceEvents(piece);
                    }
                }
            }

            createPuzzlePiece(row, col, size) {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece';
                piece.style.width = this.pieceSize + 'px';
                piece.style.height = this.pieceSize + 'px';
                piece.style.position = 'absolute';

                // ×™×¦×™×¨×ª SVG ×¢× ×¦×•×¨×ª ×¤××–×œ ×××™×ª×™×ª
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', this.pieceSize);
                svg.setAttribute('height', this.pieceSize);
                svg.setAttribute('viewBox', `0 0 ${this.pieceSize} ${this.pieceSize}`);
                svg.style.shapeRendering = 'geometricPrecision';
                svg.style.imageRendering = 'high-quality';

                // ×™×¦×™×¨×ª pattern ×¢×‘×•×¨ ×”×ª××•× ×”
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                pattern.setAttribute('id', `pattern-${row}-${col}`);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', this.pieceSize);
                pattern.setAttribute('height', this.pieceSize);

                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', this.currentImage);
                image.setAttribute('width', this.boardSize);
                image.setAttribute('height', this.boardSize);
                // ×”×ª×××ª ×”×ª××•× ×” ×œ×—×™×‘×•×¨ ××•×©×œ×
                image.setAttribute('x', -col * (this.boardSize / this.gridSize));
                image.setAttribute('y', -row * (this.boardSize / this.gridSize));

                pattern.appendChild(image);
                defs.appendChild(pattern);
                svg.appendChild(defs);

                // ×™×¦×™×¨×ª ×¦×•×¨×ª ×¤××–×œ ×××™×ª×™×ª
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', this.generateRealPuzzleShape(row, col));
                path.setAttribute('fill', `url(#pattern-${row}-${col})`);
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '1');

                svg.appendChild(path);
                piece.appendChild(svg);

                return piece;
            }

            generateRealPuzzleShape(row, col) {
                const size = this.pieceSize;
                const knobSize = 25;
                const knobDepth = 15;
                const pieceIndex = row * 3 + col;
                
                // ×”×’×“×¨×•×ª ×¦×•×¨×•×ª ×œ×¤×™ ×”××¤×¨×˜ ×”××“×•×™×§
                const pieceShapes = {
                    0: { top: 'flat', right: 'out', bottom: 'out', left: 'flat' },      // ×¤×™× ×” ×©×××œ ×¢×œ×™×•×Ÿ
                    1: { top: 'flat', right: 'in', bottom: 'out', left: 'in' },        // ×××¦×¢ ×¢×œ×™×•×Ÿ
                    2: { top: 'flat', right: 'flat', bottom: 'in', left: 'out' },      // ×¤×™× ×” ×™××™×Ÿ ×¢×œ×™×•×Ÿ
                    3: { top: 'in', right: 'out', bottom: 'out', left: 'flat' },       // ×××¦×¢ ×©×××œ
                    4: { top: 'in', right: 'in', bottom: 'in', left: 'in' },           // ××¨×›×–
                    5: { top: 'out', right: 'flat', bottom: 'out', left: 'out' },      // ×××¦×¢ ×™××™×Ÿ
                    6: { top: 'in', right: 'in', bottom: 'flat', left: 'flat' },       // ×¤×™× ×” ×©×××œ ×ª×—×ª×•×Ÿ
                    7: { top: 'out', right: 'out', bottom: 'flat', left: 'out' },      // ×××¦×¢ ×ª×—×ª×•×Ÿ
                    8: { top: 'in', right: 'flat', bottom: 'flat', left: 'in' }        // ×¤×™× ×” ×™××™×Ÿ ×ª×—×ª×•×Ÿ
                };
                
                const shape = pieceShapes[pieceIndex];
                console.log(`Piece ${pieceIndex} (${row},${col}):`, shape);
                let path = `M 0,0`;
                
                // ×¦×“ ×¢×œ×™×•×Ÿ
                if (shape.top === 'flat') {
                    path += ` L ${size},0`;
                } else if (shape.top === 'out') {
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos - knobSize},0`;
                    path += ` Q ${knobPos - knobSize/2},${0 - knobDepth} ${knobPos},${0 - knobDepth}`;
                    path += ` Q ${knobPos + knobSize/2},${0 - knobDepth} ${knobPos + knobSize},0`;
                    path += ` L ${size},0`;
                } else { // in
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos - knobSize},0`;
                    path += ` Q ${knobPos - knobSize/2},${0 + knobDepth} ${knobPos},${0 + knobDepth}`;
                    path += ` Q ${knobPos + knobSize/2},${0 + knobDepth} ${knobPos + knobSize},0`;
                    path += ` L ${size},0`;
                }
                
                // ×¦×“ ×™××™×Ÿ
                if (shape.right === 'flat') {
                    path += ` L ${size},${size}`;
                } else if (shape.right === 'out') {
                    const knobPos = size * 0.5;
                    path += ` L ${size},${knobPos - knobSize}`;
                    path += ` Q ${size + knobDepth},${knobPos - knobSize/2} ${size + knobDepth},${knobPos}`;
                    path += ` Q ${size + knobDepth},${knobPos + knobSize/2} ${size},${knobPos + knobSize}`;
                    path += ` L ${size},${size}`;
                } else { // in
                    const knobPos = size * 0.5;
                    path += ` L ${size},${knobPos - knobSize}`;
                    path += ` Q ${size - knobDepth},${knobPos - knobSize/2} ${size - knobDepth},${knobPos}`;
                    path += ` Q ${size - knobDepth},${knobPos + knobSize/2} ${size},${knobPos + knobSize}`;
                    path += ` L ${size},${size}`;
                }
                
                // ×¦×“ ×ª×—×ª×•×Ÿ
                if (shape.bottom === 'flat') {
                    path += ` L 0,${size}`;
                } else if (shape.bottom === 'out') {
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos + knobSize},${size}`;
                    path += ` Q ${knobPos + knobSize/2},${size + knobDepth} ${knobPos},${size + knobDepth}`;
                    path += ` Q ${knobPos - knobSize/2},${size + knobDepth} ${knobPos - knobSize},${size}`;
                    path += ` L 0,${size}`;
                } else { // in
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos + knobSize},${size}`;
                    path += ` Q ${knobPos + knobSize/2},${size - knobDepth} ${knobPos},${size - knobDepth}`;
                    path += ` Q ${knobPos - knobSize/2},${size - knobDepth} ${knobPos - knobSize},${size}`;
                    path += ` L 0,${size}`;
                }
                
                // ×¦×“ ×©×××œ
                if (shape.left === 'flat') {
                    path += ` L 0,0`;
                } else if (shape.left === 'out') {
                    const knobPos = size * 0.5;
                    path += ` L 0,${knobPos + knobSize}`;
                    path += ` Q ${0 - knobDepth},${knobPos + knobSize/2} ${0 - knobDepth},${knobPos}`;
                    path += ` Q ${0 - knobDepth},${knobPos - knobSize/2} 0,${knobPos - knobSize}`;
                    path += ` L 0,0`;
                } else { // in
                    const knobPos = size * 0.5;
                    path += ` L 0,${knobPos + knobSize}`;
                    path += ` Q ${0 + knobDepth},${knobPos + knobSize/2} ${0 + knobDepth},${knobPos}`;
                    path += ` Q ${0 + knobDepth},${knobPos - knobSize/2} 0,${knobPos - knobSize}`;
                    path += ` L 0,0`;
                }
                
                path += ` Z`;
                return path;
            }

            addPieceEvents(piece) {
                let isDragging = false;
                let startX, startY, initialX, initialY;

                const startDrag = (e) => {
                    if (piece.connected) return;
                    
                    isDragging = true;
                    piece.classList.add('dragging');
                    this.playSound('drag');

                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                    startX = clientX;
                    startY = clientY;
                    initialX = parseInt(piece.style.left);
                    initialY = parseInt(piece.style.top);

                    e.preventDefault();
                };

                const drag = (e) => {
                    if (!isDragging) return;

                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                    const newX = initialX + (clientX - startX);
                    const newY = initialY + (clientY - startY);

                    piece.style.left = Math.max(0, Math.min(newX, window.innerWidth - this.pieceSize)) + 'px';
                    piece.style.top = Math.max(0, Math.min(newY, window.innerHeight - this.pieceSize)) + 'px';

                    this.highlightCorrectSlot(piece);
                    e.preventDefault();
                };

                const endDrag = (e) => {
                    if (!isDragging) return;

                    isDragging = false;
                    piece.classList.remove('dragging');
                    
                    document.querySelectorAll('.puzzle-slot').forEach(slot => {
                        slot.classList.remove('highlight');
                    });

                    this.checkPieceConnection(piece);
                    e.preventDefault();
                };

                piece.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);

                piece.addEventListener('touchstart', startDrag, {passive: false});
                document.addEventListener('touchmove', drag, {passive: false});
                piece.addEventListener('touchend', endDrag, {passive: false});
            }

            highlightCorrectSlot(piece) {
                document.querySelectorAll('.puzzle-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                });

                const board = document.getElementById('puzzle-board');
                const boardRect = board.getBoundingClientRect();
                const pieceX = parseInt(piece.style.left);
                const pieceY = parseInt(piece.style.top);

                const slotSize = this.boardSize / this.gridSize;
                // ×”××™×§×•× ×”× ×›×•×Ÿ ×‘×“×™×•×§ ×¢×œ ×”×¨×™×‘×•×¢
                const correctX = boardRect.left + (piece.correctCol * slotSize);
                const correctY = boardRect.top + (piece.correctRow * slotSize);

                const tolerance = 60;
                if (Math.abs(pieceX - correctX) < tolerance && Math.abs(pieceY - correctY) < tolerance) {
                    const slot = document.querySelector(`.puzzle-slot[data-row="${piece.correctRow}"][data-col="${piece.correctCol}"]`);
                    if (slot) slot.classList.add('highlight');
                }
            }

            checkPieceConnection(piece) {
                const board = document.getElementById('puzzle-board');
                const boardRect = board.getBoundingClientRect();
                const pieceX = parseInt(piece.style.left);
                const pieceY = parseInt(piece.style.top);

                const slotSize = this.boardSize / this.gridSize;
                // ×”××™×§×•× ×”× ×›×•×Ÿ ×‘×“×™×•×§ ×¢×œ ×”×¨×™×‘×•×¢
                const correctX = boardRect.left + (piece.correctCol * slotSize);
                const correctY = boardRect.top + (piece.correctRow * slotSize);

                const tolerance = 60;
                if (Math.abs(pieceX - correctX) < tolerance && Math.abs(pieceY - correctY) < tolerance) {
                    this.connectPiece(piece, correctX, correctY);
                }
            }

            connectPiece(piece, correctX, correctY) {
                this.playSound('snap');
                
                piece.classList.add('snapping');
                setTimeout(() => piece.classList.remove('snapping'), 400);

                // ××™×§×•× ××“×•×™×§ - ×—×™×‘×•×¨ ××•×©×œ× ×œ×œ× ×¨×•×•×—×™×
                const slotSize = this.boardSize / this.gridSize;
                const boardRect = document.getElementById('puzzle-board').getBoundingClientRect();
                const exactX = boardRect.left + (piece.correctCol * slotSize);
                const exactY = boardRect.top + (piece.correctRow * slotSize);
                
                piece.style.left = exactX + 'px';
                piece.style.top = exactY + 'px';
                piece.connected = true;
                piece.classList.add('connected');
                
                // ×”×¡×¨×ª ×”×§×• ×”×œ×‘×Ÿ ××”×—×œ×§ ×”××—×•×‘×¨
                const path = piece.querySelector('path');
                if (path) {
                    path.setAttribute('stroke', 'none');
                }

                this.connectedPieces++;
                this.updateProgress();

                if (this.connectedPieces === 9) {
                    setTimeout(() => this.completePuzzle(), 500);
                }
            }

            updateProgress() {
                const percent = Math.round((this.connectedPieces / 9) * 100);
                document.getElementById('connected-count').textContent = this.connectedPieces;
                document.getElementById('progress-fill').style.width = percent + '%';
                document.getElementById('progress-percent').textContent = percent + '% ×”×•×©×œ×';
            }

            completePuzzle() {
                this.playSound('complete');
                document.getElementById('completion-message').style.display = 'block';
            }
        }

        // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
        let puzzle;

        function init() {
            puzzle = new RealPuzzle();
        }

        function shufflePieces() {
            puzzle.pieces.forEach(piece => {
                if (!piece.connected) {
                    const randomX = Math.random() * (window.innerWidth - puzzle.pieceSize);
                    const randomY = Math.random() * (window.innerHeight - puzzle.pieceSize);
                    piece.style.left = Math.max(window.innerWidth * 0.6, randomX) + 'px';
                    piece.style.top = Math.max(100, Math.min(randomY, window.innerHeight - 200)) + 'px';
                }
            });
        }

        function showHint() {
            // ×”×“×’×©×ª ×›×œ ×”××©×‘×¦×•×ª ×œ×›××” ×©× ×™×•×ª
            document.querySelectorAll('.puzzle-slot').forEach(slot => {
                slot.classList.add('highlight');
            });
            setTimeout(() => {
                document.querySelectorAll('.puzzle-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                });
            }, 2000);
        }

        function resetPuzzle() {
            document.getElementById('completion-message').style.display = 'none';
            puzzle.pieces.forEach(piece => {
                piece.connected = false;
                piece.classList.remove('connected');
            });
            puzzle.connectedPieces = 0;
            puzzle.updateProgress();
            shufflePieces();
        }

        function goBack() {
            window.location.href = 'index.html';
        }

        // ×”×ª×—×œ×”
        window.addEventListener('load', init);
    </script>
</body>
</html> 
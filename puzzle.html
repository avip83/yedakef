<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>З 驻 转 - 注拽祝</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Heebo', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .puzzle-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .puzzle-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            z-index: 1000;
        }

        .puzzle-title {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .puzzle-progress {
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 10px 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .puzzle-board {
            position: absolute;
            top: 50%;
            left: 35%;
            transform: translate(-50%, -50%);
            width: 360px;
            height: 360px;
            background: rgba(255,255,255,0.1);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.2);
        }

        .puzzle-pieces-area {
            position: absolute;
            top: 50%;
            right: 10%;
            transform: translateY(-50%);
            width: 350px;
            height: 500px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            padding: 20px;
        }

        .pieces-title {
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        .puzzle-piece {
            position: absolute;
            cursor: grab;
            transition: all 0.2s ease;
            z-index: 10;
            filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            shape-rendering: geometricPrecision;
        }

        .puzzle-piece:hover {
            transform: scale(1.05);
            z-index: 50;
            filter: drop-shadow(5px 5px 15px rgba(0,0,0,0.6));
        }

        .puzzle-piece.dragging {
            z-index: 100;
            transform: scale(1.1);
            filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.8));
            cursor: grabbing;
        }

        .puzzle-piece.connected {
            cursor: default;
            filter: none;
            z-index: 5;
        }

        .puzzle-piece.snapping {
            animation: snapPiece 0.4s ease-out;
        }

        @keyframes snapPiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); filter: drop-shadow(0 0 20px rgba(76,175,80,0.8)); }
            100% { transform: scale(1); }
        }

        .puzzle-slot {
            position: absolute;
            border: none;
            background: transparent;
            transition: all 0.3s ease;
        }

        .puzzle-slot.highlight {
            background: rgba(76,175,80,0.2);
            box-shadow: 0 0 20px rgba(76,175,80,0.6);
            border-radius: 10px;
        }

        .control-buttons {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .control-button {
            padding: 12px 24px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .control-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .back-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(244,67,54,0.8);
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(244,67,54,1);
        }

        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            z-index: 2000;
            display: none;
        }

        .completion-title {
            font-size: 2.5rem;
            color: #4caf50;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .completion-text {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div class="puzzle-container">
        <!-- Header -->
        <div class="puzzle-header">
            <div class="puzzle-title">З 驻 转</div>
            <div class="puzzle-progress">
                <div>拽 专: <span id="connected-count">0</span>/9</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div id="progress-percent">0% 砖</div>
            </div>
        </div>

        <!-- Board -->
        <div class="puzzle-board" id="puzzle-board"></div>

        <!-- Pieces Area -->
        <div class="puzzle-pieces-area">
            <div class="pieces-title">З 转转 驻</div>
            <div id="pieces-container"></div>
        </div>

        <!-- Controls -->
        <div class="control-buttons">
            <button class="control-button" onclick="shufflePieces()"> 驻专 砖</button>
            <button class="control-button" onclick="showHint()"> 专</button>
        </div>

        <!-- Back Button -->
        <button class="control-button back-button" onclick="goBack()">猬锔 专</button>

        <!-- Completion Message -->
        <div class="completion-message" id="completion-message">
            <div class="completion-title">  ! </div>
            <div class="completion-text">砖转 转 驻 爪!</div>
            <button class="control-button" onclick="resetPuzzle()"> 驻 砖</button>
            <button class="control-button" onclick="goBack()"> 专 转驻专</button>
        </div>
    </div>

    <script>
        class RealPuzzle {
            constructor() {
                this.gridSize = 3;
                this.pieceSize = 120; //  拽 转  专注
                this.boardSize = 360;
                this.pieces = [];
                this.connectedPieces = 0;
                this.currentImage = 'puzzle/1.png';
                this.sounds = {};
                this.loadSounds();
                this.init();
            }

            loadSounds() {
                this.sounds = {
                    drag: new Audio('sounds/plop-sound-made-with-my-mouth-100690 (mp3cut.net).mp3'),
                    snap: new Audio('sounds/mouse-click-290204.mp3'),
                    complete: new Audio('sounds/game-level-complete-143022.mp3')
                };
                Object.values(this.sounds).forEach(sound => sound.volume = 0.6);
            }

            playSound(type) {
                if (this.sounds[type] && !window.__globalMute) {
                    try {
                        this.sounds[type].currentTime = 0;
                        this.sounds[type].play();
                    } catch (e) {}
                }
            }

            init() {
                this.createPuzzleSlots();
                this.createPuzzlePieces();
                this.shufflePieces();
            }

            createPuzzleSlots() {
                const board = document.getElementById('puzzle-board');
                const slotSize = this.boardSize / this.gridSize;

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const slot = document.createElement('div');
                        slot.className = 'puzzle-slot';
                        // 拽 爪 专 -  专
                        slot.style.left = (col * slotSize) + 'px';
                        slot.style.top = (row * slotSize) + 'px';
                        slot.style.width = slotSize + 'px';
                        slot.style.height = slotSize + 'px';
                        slot.dataset.row = row;
                        slot.dataset.col = col;
                        board.appendChild(slot);
                    }
                }
            }

            createPuzzlePieces() {
                const container = document.getElementById('pieces-container');
                const pieceSize = this.boardSize / this.gridSize;

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const piece = this.createPuzzlePiece(row, col, pieceSize);
                        piece.correctRow = row;
                        piece.correctCol = col;
                        piece.connected = false;

                        // 拽 拽专 专 转转
                        const randomX = Math.random() * 250;
                        const randomY = Math.random() * 400;
                        piece.style.left = randomX + 'px';
                        piece.style.top = randomY + 'px';

                        document.body.appendChild(piece);
                        this.pieces.push(piece);
                        this.addPieceEvents(piece);
                    }
                }
            }

            createPuzzlePiece(row, col, size) {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece';
                piece.style.width = this.pieceSize + 'px';
                piece.style.height = this.pieceSize + 'px';
                piece.style.position = 'absolute';

                // 爪专转 SVG 注 爪专转 驻 转转
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', this.pieceSize);
                svg.setAttribute('height', this.pieceSize);
                svg.setAttribute('viewBox', `0 0 ${this.pieceSize} ${this.pieceSize}`);
                svg.style.shapeRendering = 'geometricPrecision';
                svg.style.imageRendering = 'high-quality';

                // 爪专转 pattern 注专 转
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                pattern.setAttribute('id', `pattern-${row}-${col}`);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', this.pieceSize);
                pattern.setAttribute('height', this.pieceSize);

                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', this.currentImage);
                image.setAttribute('width', this.boardSize);
                image.setAttribute('height', this.boardSize);
                // 转转 转 专 砖
                image.setAttribute('x', -col * (this.boardSize / this.gridSize));
                image.setAttribute('y', -row * (this.boardSize / this.gridSize));

                pattern.appendChild(image);
                defs.appendChild(pattern);
                svg.appendChild(defs);

                // 爪专转 爪专转 驻 转转
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', this.generateRealPuzzleShape(row, col));
                path.setAttribute('fill', `url(#pattern-${row}-${col})`);
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '1');

                svg.appendChild(path);
                piece.appendChild(svg);

                return piece;
            }

            generateRealPuzzleShape(row, col) {
                const size = this.pieceSize;
                const knobSize = 25;
                const knobDepth = 15;
                
                // 爪专转 驻转 拽注  转  砖爪专转  注拽转
                const seed = row * 1000 + col * 100;
                const random = (n) => {
                    const val = ((seed + n) * 9301 + 49297) % 233280;
                    return val / 233280;
                };
                
                let path = `M 0,0`;
                
                // 爪 注
                if (row === 0) {
                    path += ` L ${size},0`;
                } else {
                    // /专 爪专 转 转 注
                    const upperSeed = (row-1) * 1000 + col * 100;
                    const upperRandom = (n) => {
                        const val = ((upperSeed + n) * 9301 + 49297) % 233280;
                        return val / 233280;
                    };
                    const knobOut = upperRandom(3) <= 0.5; // 驻 转 注
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos - knobSize},0`;
                    
                    if (knobOut) {
                        //  注
                        path += ` Q ${knobPos - knobSize/2},${0 - knobDepth} ${knobPos},${0 - knobDepth}`;
                        path += ` Q ${knobPos + knobSize/2},${0 - knobDepth} ${knobPos + knobSize},0`;
                    } else {
                        // 专 注
                        path += ` Q ${knobPos - knobSize/2},${0 + knobDepth} ${knobPos},${0 + knobDepth}`;
                        path += ` Q ${knobPos + knobSize/2},${0 + knobDepth} ${knobPos + knobSize},0`;
                    }
                    path += ` L ${size},0`;
                }
                
                // 爪 
                if (col === this.gridSize - 1) {
                    path += ` L ${size},${size}`;
                } else {
                    const knobOut = random(2) > 0.5;
                    const knobPos = size * 0.5;
                    path += ` L ${size},${knobPos - knobSize}`;
                    
                    if (knobOut) {
                        //  
                        path += ` Q ${size+knobDepth},${knobPos - knobSize/2} ${size+knobDepth},${knobPos}`;
                        path += ` Q ${size+knobDepth},${knobPos + knobSize/2} ${size},${knobPos + knobSize}`;
                    } else {
                        // 专 
                        path += ` Q ${size-knobDepth},${knobPos - knobSize/2} ${size-knobDepth},${knobPos}`;
                        path += ` Q ${size-knobDepth},${knobPos + knobSize/2} ${size},${knobPos + knobSize}`;
                    }
                    path += ` L ${size},${size}`;
                }
                
                // 爪 转转
                if (row === this.gridSize - 1) {
                    path += ` L 0,${size}`;
                } else {
                    const knobOut = random(3) > 0.5;
                    const knobPos = size * 0.5;
                    path += ` L ${knobPos + knobSize},${size}`;
                    
                    if (knobOut) {
                        //  
                        path += ` Q ${knobPos + knobSize/2},${size+knobDepth} ${knobPos},${size+knobDepth}`;
                        path += ` Q ${knobPos - knobSize/2},${size+knobDepth} ${knobPos - knobSize},${size}`;
                    } else {
                        // 专 
                        path += ` Q ${knobPos + knobSize/2},${size-knobDepth} ${knobPos},${size-knobDepth}`;
                        path += ` Q ${knobPos - knobSize/2},${size-knobDepth} ${knobPos - knobSize},${size}`;
                    }
                    path += ` L 0,${size}`;
                }
                
                // 爪 砖
                if (col === 0) {
                    path += ` L 0,0`;
                } else {
                    // /专 爪专 转 转 砖
                    const leftSeed = row * 1000 + (col-1) * 100;
                    const leftRandom = (n) => {
                        const val = ((leftSeed + n) * 9301 + 49297) % 233280;
                        return val / 233280;
                    };
                    const knobOut = leftRandom(2) <= 0.5; // 驻 转 砖
                    const knobPos = size * 0.5;
                    path += ` L 0,${knobPos + knobSize}`;
                    
                    if (knobOut) {
                        //  砖
                        path += ` Q ${0-knobDepth},${knobPos + knobSize/2} ${0-knobDepth},${knobPos}`;
                        path += ` Q ${0-knobDepth},${knobPos - knobSize/2} 0,${knobPos - knobSize}`;
                    } else {
                        // 专 砖
                        path += ` Q ${0+knobDepth},${knobPos + knobSize/2} ${0+knobDepth},${knobPos}`;
                        path += ` Q ${0+knobDepth},${knobPos - knobSize/2} 0,${knobPos - knobSize}`;
                    }
                    path += ` L 0,0`;
                }
                
                path += ` Z`;
                return path;
            }

            addPieceEvents(piece) {
                let isDragging = false;
                let startX, startY, initialX, initialY;

                const startDrag = (e) => {
                    if (piece.connected) return;
                    
                    isDragging = true;
                    piece.classList.add('dragging');
                    this.playSound('drag');

                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                    startX = clientX;
                    startY = clientY;
                    initialX = parseInt(piece.style.left);
                    initialY = parseInt(piece.style.top);

                    e.preventDefault();
                };

                const drag = (e) => {
                    if (!isDragging) return;

                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                    const newX = initialX + (clientX - startX);
                    const newY = initialY + (clientY - startY);

                    piece.style.left = Math.max(0, Math.min(newX, window.innerWidth - this.pieceSize)) + 'px';
                    piece.style.top = Math.max(0, Math.min(newY, window.innerHeight - this.pieceSize)) + 'px';

                    this.highlightCorrectSlot(piece);
                    e.preventDefault();
                };

                const endDrag = (e) => {
                    if (!isDragging) return;

                    isDragging = false;
                    piece.classList.remove('dragging');
                    
                    document.querySelectorAll('.puzzle-slot').forEach(slot => {
                        slot.classList.remove('highlight');
                    });

                    this.checkPieceConnection(piece);
                    e.preventDefault();
                };

                piece.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);

                piece.addEventListener('touchstart', startDrag, {passive: false});
                document.addEventListener('touchmove', drag, {passive: false});
                piece.addEventListener('touchend', endDrag, {passive: false});
            }

            highlightCorrectSlot(piece) {
                document.querySelectorAll('.puzzle-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                });

                const board = document.getElementById('puzzle-board');
                const boardRect = board.getBoundingClientRect();
                const pieceX = parseInt(piece.style.left);
                const pieceY = parseInt(piece.style.top);

                const slotSize = this.boardSize / this.gridSize;
                // 拽  拽 注 专注
                const correctX = boardRect.left + (piece.correctCol * slotSize);
                const correctY = boardRect.top + (piece.correctRow * slotSize);

                const tolerance = 60;
                if (Math.abs(pieceX - correctX) < tolerance && Math.abs(pieceY - correctY) < tolerance) {
                    const slot = document.querySelector(`.puzzle-slot[data-row="${piece.correctRow}"][data-col="${piece.correctCol}"]`);
                    if (slot) slot.classList.add('highlight');
                }
            }

            checkPieceConnection(piece) {
                const board = document.getElementById('puzzle-board');
                const boardRect = board.getBoundingClientRect();
                const pieceX = parseInt(piece.style.left);
                const pieceY = parseInt(piece.style.top);

                const slotSize = this.boardSize / this.gridSize;
                // 拽  拽 注 专注
                const correctX = boardRect.left + (piece.correctCol * slotSize);
                const correctY = boardRect.top + (piece.correctRow * slotSize);

                const tolerance = 60;
                if (Math.abs(pieceX - correctX) < tolerance && Math.abs(pieceY - correctY) < tolerance) {
                    this.connectPiece(piece, correctX, correctY);
                }
            }

            connectPiece(piece, correctX, correctY) {
                this.playSound('snap');
                
                piece.classList.add('snapping');
                setTimeout(() => piece.classList.remove('snapping'), 400);

                // 拽 拽 - 专 砖  专
                const slotSize = this.boardSize / this.gridSize;
                const boardRect = document.getElementById('puzzle-board').getBoundingClientRect();
                const exactX = boardRect.left + (piece.correctCol * slotSize);
                const exactY = boardRect.top + (piece.correctRow * slotSize);
                
                piece.style.left = exactX + 'px';
                piece.style.top = exactY + 'px';
                piece.connected = true;
                piece.classList.add('connected');
                
                // 住专转 拽  拽 专
                const path = piece.querySelector('path');
                if (path) {
                    path.setAttribute('stroke', 'none');
                }

                this.connectedPieces++;
                this.updateProgress();

                if (this.connectedPieces === 9) {
                    setTimeout(() => this.completePuzzle(), 500);
                }
            }

            updateProgress() {
                const percent = Math.round((this.connectedPieces / 9) * 100);
                document.getElementById('connected-count').textContent = this.connectedPieces;
                document.getElementById('progress-fill').style.width = percent + '%';
                document.getElementById('progress-percent').textContent = percent + '% 砖';
            }

            completePuzzle() {
                this.playSound('complete');
                document.getElementById('completion-message').style.display = 'block';
            }
        }

        // 驻拽爪转 注专
        let puzzle;

        function init() {
            puzzle = new RealPuzzle();
        }

        function shufflePieces() {
            puzzle.pieces.forEach(piece => {
                if (!piece.connected) {
                    const randomX = Math.random() * (window.innerWidth - puzzle.pieceSize);
                    const randomY = Math.random() * (window.innerHeight - puzzle.pieceSize);
                    piece.style.left = Math.max(window.innerWidth * 0.6, randomX) + 'px';
                    piece.style.top = Math.max(100, Math.min(randomY, window.innerHeight - 200)) + 'px';
                }
            });
        }

        function showHint() {
            // 砖转  砖爪转  砖转
            document.querySelectorAll('.puzzle-slot').forEach(slot => {
                slot.classList.add('highlight');
            });
            setTimeout(() => {
                document.querySelectorAll('.puzzle-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                });
            }, 2000);
        }

        function resetPuzzle() {
            document.getElementById('completion-message').style.display = 'none';
            puzzle.pieces.forEach(piece => {
                piece.connected = false;
                piece.classList.remove('connected');
            });
            puzzle.connectedPieces = 0;
            puzzle.updateProgress();
            shufflePieces();
        }

        function goBack() {
            window.location.href = 'index.html';
        }

        // 转
        window.addEventListener('load', init);
    </script>
</body>
</html> 
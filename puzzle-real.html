<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>З 驻 转 砖</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        
        .puzzle-area {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
            margin-top: 30px;
        }
        
        .puzzle-board {
            width: 480px;
            height: 480px;
            background: rgba(255,255,255,0.2);
            border: 3px solid white;
            border-radius: 15px;
            position: relative;
        }
        
        .pieces-container {
            width: 400px;
            min-height: 500px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
        }
        
        .puzzle-piece {
            position: absolute;
            cursor: grab;
            transition: transform 0.2s ease;
            z-index: 10;
        }
        
        .puzzle-piece:hover {
            transform: scale(1.05);
        }
        
        .puzzle-piece:active {
            cursor: grabbing;
            z-index: 1000;
        }
        
        .puzzle-piece.placed {
            cursor: default;
        }
        
        .puzzle-slot {
            position: absolute;
            border: 2px dashed rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.05);
        }
        
        .puzzle-slot.highlight {
            border-color: #ffeb3b;
            background: rgba(255,235,59,0.2);
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
        }
        
        button:hover {
            background: #f0f0f0;
        }
        
        .status {
            margin: 20px 0;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>З 驻 转 砖</h1>
        <div class="status">
            <div>拽 拽: <span id="placed-count">0</span>/9</div>
        </div>
        
        <div class="puzzle-area">
            <div class="pieces-container" id="pieces-container">
                <h3 style="width: 100%; margin-top: 0;">拽 驻</h3>
            </div>
            
            <div class="puzzle-board" id="puzzle-board"></div>
        </div>
        
        <button onclick="resetPuzzle()">驻住 驻</button>
        <button onclick="showShapes()">爪 爪专转</button>
    </div>

    <script>
        class RealPuzzle {
            constructor() {
                this.gridSize = 3;
                this.pieceSize = 160;
                this.pieces = [];
                this.placedPieces = 0;
                this.currentImage = 'puzzle/6.png';
                
                // 专转 爪专转 拽 驻  砖拽砖转
                // false = 拽 砖专, true = , -1 = 专
                this.pieceShapes = {
                    0: { top: false, right: true, bottom: true, left: false },    // 驻 砖 注: 拽 注 砖,   
                    1: { top: false, right: -1, bottom: true, left: -1 },         // 爪注 注: 拽 注, 专 砖 ,  
                    2: { top: false, right: false, bottom: -1, left: true },      // 驻  注: 拽 注 , 专 ,  砖
                    3: { top: -1, right: true, bottom: true, left: false },       // 爪注 砖: 拽 砖, 专 注, 转  
                    4: { top: -1, right: -1, bottom: -1, left: -1 },              // 专: 专  爪
                    5: { top: true, right: false, bottom: true, left: true },     // 爪注 : 拽 , 转 砖专 爪
                    6: { top: -1, right: -1, bottom: false, left: false },        // 驻 砖 转转: 拽 转转 砖, 专 注 
                    7: { top: true, right: true, bottom: false, left: true },     // 爪注 转转: 拽 转转, 转 砖专 爪
                    8: { top: -1, right: false, bottom: false, left: -1 }         // 驻  转转: 拽 转转 , 专 注 砖
                };
                
                this.init();
            }
            
            init() {
                console.log('爪专 驻 砖 驻住!');
                this.createPuzzleSlots();
                this.createPuzzlePieces();
                this.shufflePieces();
            }
            
            createPuzzleSlots() {
                const board = document.getElementById('puzzle-board');
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const slot = document.createElement('div');
                        slot.className = 'puzzle-slot';
                        slot.style.left = (col * this.pieceSize) + 'px';
                        slot.style.top = (row * this.pieceSize) + 'px';
                        slot.style.width = this.pieceSize + 'px';
                        slot.style.height = this.pieceSize + 'px';
                        slot.dataset.row = row;
                        slot.dataset.col = col;
                        board.appendChild(slot);
                    }
                }
            }
            
            createPuzzlePieces() {
                const container = document.getElementById('pieces-container');
                
                for (let i = 0; i < 9; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    const shape = this.pieceShapes[i];
                    
                    console.log(`爪专 拽 ${i} (${row},${col}):`, shape);
                    
                    const piece = this.createSinglePiece(i, row, col, shape);
                    container.appendChild(piece);
                    this.pieces.push(piece);
                    this.addDragEvents(piece);
                }
            }
            
            createSinglePiece(index, row, col, shape) {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece';
                piece.dataset.index = index;
                piece.dataset.correctRow = row;
                piece.dataset.correctCol = col;
                piece.style.width = this.pieceSize + 'px';
                piece.style.height = this.pieceSize + 'px';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', this.pieceSize);
                svg.setAttribute('height', this.pieceSize);
                svg.style.pointerEvents = 'none';
                
                // 爪专转 爪专
                const path = this.generatePiecePath(shape);
                console.log(`拽 ${index} - 爪专:`, shape, '转:', path.substring(0, 50) + '...');
                
                // 驻住 转 转
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPath.setAttribute('id', `clip-${index}`);
                
                const clipPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clipPathEl.setAttribute('d', path);
                clipPath.appendChild(clipPathEl);
                defs.appendChild(clipPath);
                svg.appendChild(defs);
                
                // 转
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', this.currentImage);
                image.setAttribute('x', -col * this.pieceSize);
                image.setAttribute('y', -row * this.pieceSize);
                image.setAttribute('width', this.pieceSize * 3);
                image.setAttribute('height', this.pieceSize * 3);
                image.setAttribute('clip-path', `url(#clip-${index})`);
                svg.appendChild(image);
                
                // 住专转
                const border = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                border.setAttribute('d', path);
                border.setAttribute('fill', 'none');
                border.setAttribute('stroke', '#333');
                border.setAttribute('stroke-width', '2');
                svg.appendChild(border);
                
                piece.appendChild(svg);
                return piece;
            }
            
            generatePiecePath(shape) {
                const size = this.pieceSize;
                const knobSize = 25;
                const knobDepth = 15;
                
                let path = `M 0,0`;
                
                // 爪 注
                if (shape.top === false) {
                    // 拽 砖专
                    path += ` L ${size},0`;
                } else if (shape.top === true) {
                    // 
                    const mid = size / 2;
                    path += ` L ${mid - knobSize},0`;
                    path += ` Q ${mid - knobSize/2},${-knobDepth} ${mid},${-knobDepth}`;
                    path += ` Q ${mid + knobSize/2},${-knobDepth} ${mid + knobSize},0`;
                    path += ` L ${size},0`;
                } else {
                    // 专 (shape.top === -1)
                    const mid = size / 2;
                    path += ` L ${mid - knobSize},0`;
                    path += ` Q ${mid - knobSize/2},${knobDepth} ${mid},${knobDepth}`;
                    path += ` Q ${mid + knobSize/2},${knobDepth} ${mid + knobSize},0`;
                    path += ` L ${size},0`;
                }
                
                // 爪 
                if (shape.right === false) {
                    // 拽 砖专
                    path += ` L ${size},${size}`;
                } else if (shape.right === true) {
                    // 
                    const mid = size / 2;
                    path += ` L ${size},${mid - knobSize}`;
                    path += ` Q ${size + knobDepth},${mid - knobSize/2} ${size + knobDepth},${mid}`;
                    path += ` Q ${size + knobDepth},${mid + knobSize/2} ${size},${mid + knobSize}`;
                    path += ` L ${size},${size}`;
                } else {
                    // 专
                    const mid = size / 2;
                    path += ` L ${size},${mid - knobSize}`;
                    path += ` Q ${size - knobDepth},${mid - knobSize/2} ${size - knobDepth},${mid}`;
                    path += ` Q ${size - knobDepth},${mid + knobSize/2} ${size},${mid + knobSize}`;
                    path += ` L ${size},${size}`;
                }
                
                // 爪 转转
                if (shape.bottom === false) {
                    // 拽 砖专
                    path += ` L 0,${size}`;
                } else if (shape.bottom === true) {
                    // 
                    const mid = size / 2;
                    path += ` L ${mid + knobSize},${size}`;
                    path += ` Q ${mid + knobSize/2},${size + knobDepth} ${mid},${size + knobDepth}`;
                    path += ` Q ${mid - knobSize/2},${size + knobDepth} ${mid - knobSize},${size}`;
                    path += ` L 0,${size}`;
                } else {
                    // 专
                    const mid = size / 2;
                    path += ` L ${mid + knobSize},${size}`;
                    path += ` Q ${mid + knobSize/2},${size - knobDepth} ${mid},${size - knobDepth}`;
                    path += ` Q ${mid - knobSize/2},${size - knobDepth} ${mid - knobSize},${size}`;
                    path += ` L 0,${size}`;
                }
                
                // 爪 砖
                if (shape.left === false) {
                    // 拽 砖专
                    path += ` L 0,0`;
                } else if (shape.left === true) {
                    // 
                    const mid = size / 2;
                    path += ` L 0,${mid + knobSize}`;
                    path += ` Q ${-knobDepth},${mid + knobSize/2} ${-knobDepth},${mid}`;
                    path += ` Q ${-knobDepth},${mid - knobSize/2} 0,${mid - knobSize}`;
                    path += ` L 0,0`;
                } else {
                    // 专
                    const mid = size / 2;
                    path += ` L 0,${mid + knobSize}`;
                    path += ` Q ${knobDepth},${mid + knobSize/2} ${knobDepth},${mid}`;
                    path += ` Q ${knobDepth},${mid - knobSize/2} 0,${mid - knobSize}`;
                    path += ` L 0,0`;
                }
                
                path += ' Z';
                return path;
            }
            
            addDragEvents(piece) {
                let isDragging = false;
                let startX, startY, initialX, initialY;
                
                piece.addEventListener('mousedown', (e) => {
                    if (piece.classList.contains('placed')) return;
                    
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    const rect = piece.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;
                    
                    piece.style.zIndex = '1000';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    piece.style.position = 'fixed';
                    piece.style.left = (initialX + deltaX) + 'px';
                    piece.style.top = (initialY + deltaY) + 'px';
                    
                    this.highlightNearestSlot(piece);
                });
                
                document.addEventListener('mouseup', () => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    piece.style.zIndex = '10';
                    this.checkPiecePlacement(piece);
                    this.clearHighlights();
                });
            }
            
            highlightNearestSlot(piece) {
                this.clearHighlights();
                
                const correctRow = parseInt(piece.dataset.correctRow);
                const correctCol = parseInt(piece.dataset.correctCol);
                const slot = document.querySelector(`[data-row="${correctRow}"][data-col="${correctCol}"]`);
                
                if (slot) {
                    const slotRect = slot.getBoundingClientRect();
                    const pieceRect = piece.getBoundingClientRect();
                    
                    const distance = Math.sqrt(
                        Math.pow(slotRect.left - pieceRect.left, 2) +
                        Math.pow(slotRect.top - pieceRect.top, 2)
                    );
                    
                    if (distance < 80) {
                        slot.classList.add('highlight');
                    }
                }
            }
            
            clearHighlights() {
                document.querySelectorAll('.puzzle-slot').forEach(slot => {
                    slot.classList.remove('highlight');
                });
            }
            
            checkPiecePlacement(piece) {
                const correctRow = parseInt(piece.dataset.correctRow);
                const correctCol = parseInt(piece.dataset.correctCol);
                const board = document.getElementById('puzzle-board');
                const boardRect = board.getBoundingClientRect();
                
                const targetX = boardRect.left + (correctCol * this.pieceSize);
                const targetY = boardRect.top + (correctRow * this.pieceSize);
                
                const pieceRect = piece.getBoundingClientRect();
                const distance = Math.sqrt(
                    Math.pow(pieceRect.left - targetX, 2) +
                    Math.pow(pieceRect.top - targetY, 2)
                );
                
                if (distance < 60) {
                    // 拽 转 拽 拽 
                    piece.style.position = 'absolute';
                    piece.style.left = (correctCol * this.pieceSize) + 'px';
                    piece.style.top = (correctRow * this.pieceSize) + 'px';
                    piece.classList.add('placed');
                    
                    board.appendChild(piece);
                    this.placedPieces++;
                    this.updateStatus();
                    
                    if (this.placedPieces === 9) {
                        setTimeout(() => {
                            alert('  ! 砖转 转 驻!');
                        }, 500);
                    }
                }
            }
            
            updateStatus() {
                document.getElementById('placed-count').textContent = this.placedPieces;
            }
            
            shufflePieces() {
                this.pieces.forEach((piece, index) => {
                    const x = (index % 3) * 120 + Math.random() * 30;
                    const y = Math.floor(index / 3) * 120 + Math.random() * 30 + 50;
                    piece.style.left = x + 'px';
                    piece.style.top = y + 'px';
                });
            }
        }
        
        function resetPuzzle() {
            location.reload();
        }
        
        function showShapes() {
            const shapes = {
                0: '驻 砖 注: 拽 注 砖,   ',
                1: '爪注 注: 拽 注, 专 砖 ,  ',
                2: '驻  注: 拽 注 , 专 ,  砖',
                3: '爪注 砖: 拽 砖, 专 注, 转  ',
                4: '专: 专  爪',
                5: '爪注 : 拽 , 转 砖专 爪',
                6: '驻 砖 转转: 拽 转转 砖, 专 注 ',
                7: '爪注 转转: 拽 转转, 转 砖专 爪',
                8: '驻  转转: 拽 转转 , 专 注 砖'
            };
            
            let text = '爪专转 拽:\n\n';
            for (let i = 0; i < 9; i++) {
                text += `${i}: ${shapes[i]}\n`;
            }
            alert(text);
        }
        
        // 爪专转 驻
        window.addEventListener('load', () => {
            new RealPuzzle();
        });
    </script>
</body>
</html>
